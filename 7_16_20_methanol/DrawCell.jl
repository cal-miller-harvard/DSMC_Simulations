using Luxor
using Printf

import Base.+
+(a::Point, b::Array{Point, 1}) = [a .+ i for i in b]

function divide_line(a::Point, b::Point, max_len::Number)
    Δ = b - a
    len = sqrt(Δ.x^2+Δ.y^2)
    segments = convert(Int64,len ÷ max_len + 1)
    points = [a + i*Δ for i in range(0, 1, length=segments+1)]
    return points
end

function divide_polygon(polygon, max_len::Number)
    l = length(polygon)
    out = Vector{Point}(undef, 0)
    for i in 1:l-1
        append!(out, divide_line(polygon[i], polygon[i+1], max_len)[1:end-1])
    end
    append!(out, divide_line(polygon[l], polygon[1],max_len)[1:end-1])
    return out
end

function toSPARTA(polygons, fname)
    npts = 0
    pts = Array{Tuple{Int32, Float64, Float64}}(undef, 0)
    lines = Array{Tuple{Int32, Int32, Int32}}(undef, 0)

    for pg in polygons
        firstpt = npts + 1
        for p in pg
            npts += 1
            push!(pts, (npts, round(p.x/(1000*mm), digits=5), round(p.y/(1000*mm),digits=5)))
            push!(lines, (npts, npts, npts+1))
        end
        lines[end] = (npts, npts, firstpt)
    end
    open(fname, "w") do f
        @printf(f, "Generated by DrawCell.jl\n\n%d points\n%d lines\n\nPoints\n\n", npts, npts)
        for p in pts
            @printf(f, "%d %.3E %.3E\n", p[1], p[2], p[3])
        end
        @printf(f, "\nLines\n\n")
        for l in lines
            @printf(f, "%d %d %d\n", l[1], l[3], l[2])
        end
    end
end

function make_stage(len, id, od, raperture, taperture)
    return [
        Point(0, id),
        Point(len, id),
        Point(len, raperture),
        Point(len+taperture, raperture),
        Point(len+taperture, od),
        Point(0, od)
    ]
end

function make_mesh(dir, n, t, l, sep)
    if dir == :x
        return [box(Point(i*sep, 0), Point(i*sep + l, t)) for i in 0:n-1]
    elseif dir == :y
        return [box(Point(0, i*sep), Point(t, i*sep + l)) for i in 0:n-1]
    else
        throw(ArgumentError("dir must be :x or :y"))
    end
    return 0
end